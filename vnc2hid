#!/usr/bin/env python3
"""vnc2hid: A VNC server that extracts the HID events

Usage:
    vnc2hid <port> <width> <height>
"""

import sys
import socketserver
import struct
import binascii


class Server(socketserver.TCPServer):
    """Just override the reuseaddr"""
    allow_reuse_address = True


class VNCProto():
    def __init__(self, rfile, wfile):
        self.rfile = rfile
        self.wfile = wfile
        self.mouse_x = 0
        self.mouse_y = 0
        self.keys_shift = 0
        self.keys = []

    def handle(self):
        # We should now be dealing with messages
        while (True):
            result = self.read()
            if not result:
                return

    def read(self):
        """Process incoming bytes."""

        msgtypes = {
            0: 'SetPixelFormat',
            2: 'SetEncodings',
            3: 'FramebufferUpdateRequest',
            4: 'KeyEvent',
            5: 'PointerEvent',
            6: 'ClientCutText',
        }

        buf = self.rfile.read(1)
        if not buf:
            return None
        msgid = ord(buf)

        if msgid not in msgtypes:
            print("ABORT: Unknown message-type {}".format(msgid))
            # If we dont know the message, we will probably end up with an
            # unsynced protocol stream, so the exception will kill off our
            # connection and force a reconnect.
            raise ValueError

        msgname = msgtypes[msgid]

        # TODO: if verbose, show all packets?
        # print("{} {}".format(msgid, msgname))

        handler = getattr(self, 'recv_'+msgname, None)
        if callable(handler):
            return handler()

        return None

    def sendServerInit(self):
        global width
        global height
        bpp = 32
        depth = 24
        bigendian = False
        truecolor = True
        name = bytes('hid', 'utf8')

        buf = struct.pack(
            '!HHBB??HHHBBBxxxL',
            width, height, bpp, depth, bigendian,
            truecolor,
            255, 255, 255,  # rgb max
            16, 8, 0,       # rgb shift
            len(name)
        )
        buf += name
        self.wfile.write(buf)

    def recv_SetPixelFormat(self):
        self.rfile.read(19)
        return True

    def recv_SetEncodings(self):
        self.rfile.read(1)  # padding
        count = int.from_bytes(self.rfile.read(2), 'big')
        self.rfile.read(count*4)  # encoding list
        return True

    def recv_FramebufferUpdateRequest(self):
        self.rfile.read(9)
        return True

    def recv_KeyEvent(self):
        buf = self.rfile.read(7)
        down, key = struct.unpack("!?xxI",buf)

        keysym_shift = {
            0xffe1: 0x02,   # Shift left
            0xffe2: 0x20,   # Shift right
            0xffe3: 0x01,   # Ctrl left
            0xffe4: 0x10,   # Ctrl right
            0xffe7: 0x08,   # Meta left
            0xffe8: 0x80,   # Meta right
            0xffe9: 0x04,   # Alt left
            0xffea: 0x40,   # Alt right
        }
        if key in keysym_shift:
            # handle shift keys
            if down:
                self.keys_shift |= keysym_shift[key]
            else:
                self.keys_shift &= ~keysym_shift[key]

        else:
            # handle non shift keys

            xlat = {
                ord('!'): 30,
                ord('@'): 31,
                ord('#'): 32,
                ord('$'): 33,
                ord('%'): 34,
                ord('^'): 35,
                ord('&'): 36,
                ord('*'): 37,
                ord('('): 38,
                ord(')'): 39, ord('0'): 39,
                0xff0d: 40,  # Enter
                0xff1b: 41,  # ESC
                0xff08: 42,  # Backspace
                0xff09: 43,  # Tab
                ord(' '): 44,
                ord('-'): 45, ord('_'): 45,
                ord('='): 46, ord('+'): 46,
                ord('['): 47, ord('{'): 47,
                ord(']'): 48, ord('}'): 48,
                ord('\\'): 49, ord('|'): 49,
                # 50?
                ord(';'): 51, ord(':'): 51,
                ord("'"): 52, ord('"'): 52,
                ord('`'): 53, ord('~'): 53,
                ord(','): 54, ord('<'): 54,
                ord('.'): 55, ord('>'): 55,
                ord('/'): 56, ord('?'): 56,
                0xffe5: 57,  # capslock
                0xffbe: 58,  # F1
                0xffbf: 59,  # F2
                0xffc0: 60,  # F3
                0xffc1: 61,  # F4
                0xffc2: 62,  # F5
                0xffc3: 63,  # F6
                0xffc4: 64,  # F7
                0xffc5: 65,  # F8
                0xffc6: 66,  # F9
                0xffc7: 67,  # F10
                0xffc8: 68,  # F11
                0xffc9: 69,  # F12
                0xff61: 70,  # PrScr
                0xff14: 71,  # ScLk
                0xff13: 72,  # Pause
                0xff63: 73,  # Ins
                0xff50: 74,  # Home
                0xff55: 75,  # PgUp
                0xffff: 76,  # Del
                0xff57: 77,  # End
                0xff56: 78,  # PgDn
                0xff53: 79,  # Right
                0xff51: 80,  # Left
                0xff54: 81,  # Down
                0xff52: 82,  # Up
                0xff7f: 83,  # NumLk
                0xffaf: 84,  # KP /
                0xffaa: 85,  # KP *
                0xffad: 86,  # KP -
                0xffab: 87,  # KP +
                0xff8d: 88,  # KP Enter
                0xff9c: 89, 0xffb1: 89,  # KP 1
                0xff99: 90, 0xffb2: 90,  # KP 2
                0xff9b: 91, 0xffb3: 91,  # KP 3
                0xff96: 92, 0xffb4: 92,  # KP 4
                0xff9d: 93, 0xffb5: 93,  # KP 5
                0xff98: 94, 0xffb6: 94,  # KP 6
                0xff95: 95, 0xffb7: 95,  # KP 7
                0xff97: 96, 0xffb8: 96,  # KP 8
                0xff9a: 97, 0xffb9: 97,  # KP 9
                0xff9e: 98, 0xffb0: 98,  # KP 0
                0xff9f: 99, 0xffae: 99,  # KP .
            }
            if key in xlat:
                usbkey = xlat[key]
            elif key >= ord('A') and key <= ord('Z'):
                usbkey = key - ord('A') + 4
            elif key >= ord('a') and key <= ord('z'):
                usbkey = key - ord('a') + 4
            elif key >= ord('1') and key <= ord('9'):
                usbkey = key - ord('1') + 30
            else:
                usbkey = 3
                print("Unknown")

            if down:
                if usbkey not in self.keys:
                    self.keys.append(usbkey)
            else:
                if usbkey in self.keys:
                    self.keys.remove(usbkey)

        report = struct.pack("Bx6s", self.keys_shift, bytes(self.keys))

        if down:
            downstr = "Down"
        else:
            downstr = "Up  "
        print("Key ({}) {} 0x{:04x}".format(
            binascii.hexlify(report),
            downstr, key, self.keys_shift
        ))
        return True

    def recv_PointerEvent(self):
        buf = self.rfile.read(5)
        buttons, x, y = struct.unpack("!BHH",buf)

        delta_x = x - self.mouse_x
        delta_y = y - self.mouse_y

        overflow=False
        if delta_x > 127:
            overflow=True
            delta_x = 127
        elif delta_x < -128:
            overflow=True
            delta_x = -128

        if delta_y > 127:
            overflow=True
            delta_y = 127
        elif delta_y < -128:
            overflow=True
            delta_y = -128

        self.mouse_x += delta_x
        self.mouse_y += delta_y

        if overflow:
            # The only overflow seen so far appears to be entering/exiting
            # the x2vnc window.  Lets just ignore that one
            delta_x = 0
            delta_y = 0
        report = struct.pack("!Bbb", buttons, delta_x, delta_y)

        print("Mouse ({}) {} {} {}".format(
            binascii.hexlify(report),
            overflow,
            x, y,
        ))
        return True

    def recv_ClientCutText(self):
        self.rfile.read(3)  # padding
        length = int.from_bytes(self.rfile.read(4), 'big')
        self.rfile.read(length)
        return True


class VNCProto3(VNCProto):
    def doSecurityHandshake(self):
        # 1==no authentication
        self.wfile.write(b"\x00\x00\x00\x01")


class VNCProto8(VNCProto):
    def doSecurityHandshake(self):
        # Send Security Handshake
        # list of 1 security type, it is 1=="None"
        self.wfile.write(b"\x01\x01")

        # Recv Chosen security type
        got = self.rfile.read(1)
        assert(b"\x01" == got)

        # Send SecurityResult
        self.wfile.write(b"\x00\x00\x00\x00")


class VNCHandler(socketserver.StreamRequestHandler):

    def _doVersion(self):
        version = b"RFB 003.008\n"
        self.wfile.write(version)

        got = self.rfile.readline().strip()
        print("Client Version:{}", got)

        if (got == b'RFB 003.008'):
            self.vnc = VNCProto8(self.rfile, self.wfile)
            return

        # The standard says "if you dont know the proto, it is probably 3.3"
        self.vnc = VNCProto3(self.rfile, self.wfile)

    def handle(self):
        """Incoming connections end up here"""
        print("New connection")

        self._doVersion()
        self.vnc.doSecurityHandshake()

        # Recv ClientInit
        self.rfile.read(1)
        # we dont care what the sharing state is..

        self.vnc.sendServerInit()
        self.vnc.handle()


def main():
    if len(sys.argv) < 4:
        print(__doc__)
        return 0

    sys.argv.pop(0)

    # TODO
    # - we should have a global object that handles screen-side details
    # - each client connection should have an object that handles protocol
    #   differences and then just references the screen-side details
    # - the global screen object then should have the width and height..
    global width
    global height

    try:
        port = int(sys.argv.pop(0))
        width = int(sys.argv.pop(0))
        height = int(sys.argv.pop(0))
    except ValueError:
        print("Invalid integer argument")
        return 1

    # bind address
    host = ''

    with Server((host, port), VNCHandler) as server:
        server.serve_forever()


if __name__ == "__main__":
    sys.exit(main())
