#!/usr/bin/env python3
"""vnc2hid: A VNC server that extracts the HID events

Usage:
    vnc2hid <port> <width> <height>
"""

import sys
import socketserver
import struct


class Server(socketserver.TCPServer):
    """Just override the reuseaddr"""
    allow_reuse_address = True


class VNCProto():
    def __init__(self, rfile, wfile):
        self.rfile = rfile
        self.wfile = wfile
        self.mouse_x = 0
        self.mouse_y = 0

    def handle(self):
        # We should now be dealing with messages
        while (True):
            result = self.read()
            if not result:
                return

    def read(self):
        """Process incoming bytes."""

        msgtypes = {
            0: 'SetPixelFormat',
            2: 'SetEncodings',
            3: 'FramebufferUpdateRequest',
            4: 'KeyEvent',
            5: 'PointerEvent',
            6: 'ClientCutText',
        }

        buf = self.rfile.read(1)
        if not buf:
            return None
        msgid = ord(buf)

        if msgid not in msgtypes:
            print("ABORT: Unknown message-type {}".format(msgid))
            # If we dont know the message, we will probably end up with an
            # unsynced protocol stream, so the exception will kill off our
            # connection and force a reconnect.
            raise ValueError

        msgname = msgtypes[msgid]

        # TODO: if verbose, show all packets?
        # print("{} {}".format(msgid, msgname))

        handler = getattr(self, 'recv_'+msgname, None)
        if callable(handler):
            return handler()

        return None

    def sendServerInit(self):
        global width
        global height
        bpp = 32
        depth = 24
        bigendian = False
        truecolor = True
        name = bytes('hid', 'utf8')

        buf = struct.pack(
            '!HHBB??HHHBBBxxxL',
            width, height, bpp, depth, bigendian,
            truecolor,
            255, 255, 255,  # rgb max
            16, 8, 0,       # rgb shift
            len(name)
        )
        buf += name
        self.wfile.write(buf)

    def recv_SetPixelFormat(self):
        self.rfile.read(19)
        return True

    def recv_SetEncodings(self):
        self.rfile.read(1)  # padding
        count = int.from_bytes(self.rfile.read(2), 'big')
        self.rfile.read(count*4)  # encoding list
        return True

    def recv_FramebufferUpdateRequest(self):
        self.rfile.read(9)
        return True

    def recv_KeyEvent(self):
        buf = self.rfile.read(7)
        down, key = struct.unpack("!?xxI",buf)
        print("Key {} {}".format(down, key))
        return True

    def recv_PointerEvent(self):
        buf = self.rfile.read(5)
        buttons, x, y = struct.unpack("!BHH",buf)

        delta_x = x - self.mouse_x
        delta_y = y - self.mouse_y
        self.mouse_x = x
        self.mouse_y = y
        print("Mouse {} {} {} ({} {})".format(buttons, x, y, delta_x, delta_y))
        return True

    def recv_ClientCutText(self):
        self.rfile.read(3)  # padding
        length = int.from_bytes(self.rfile.read(4), 'big')
        self.rfile.read(length)
        return True


class VNCProto3(VNCProto):
    def doSecurityHandshake(self):
        # 1==no authentication
        self.wfile.write(b"\x00\x00\x00\x01")


class VNCProto8(VNCProto):
    def doSecurityHandshake(self):
        # Send Security Handshake
        # list of 1 security type, it is 1=="None"
        self.wfile.write(b"\x01\x01")

        # Recv Chosen security type
        got = self.rfile.read(1)
        assert(b"\x01" == got)

        # Send SecurityResult
        self.wfile.write(b"\x00\x00\x00\x00")


class VNCHandler(socketserver.StreamRequestHandler):

    def _doVersion(self):
        version = b"RFB 003.008\n"
        self.wfile.write(version)

        got = self.rfile.readline().strip()
        print("Client Version:{}", got)

        if (got == b'RFB 003.008'):
            self.vnc = VNCProto8(self.rfile, self.wfile)
            return

        # The standard says "if you dont know the proto, it is probably 3.3"
        self.vnc = VNCProto3(self.rfile, self.wfile)

    def handle(self):
        """Incoming connections end up here"""
        print("New connection")

        self._doVersion()
        self.vnc.doSecurityHandshake()

        # Recv ClientInit
        self.rfile.read(1)
        # we dont care what the sharing state is..

        self.vnc.sendServerInit()
        self.vnc.handle()


def main():
    if len(sys.argv) < 4:
        print(__doc__)
        return 0

    sys.argv.pop(0)

    # TODO
    # - we should have a global object that handles screen-side details
    # - each client connection should have an object that handles protocol
    #   differences and then just references the screen-side details
    # - the global screen object then should have the width and height..
    global width
    global height

    try:
        port = int(sys.argv.pop(0))
        width = int(sys.argv.pop(0))
        height = int(sys.argv.pop(0))
    except ValueError:
        print("Invalid integer argument")
        return 1

    # bind address
    host = ''

    with Server((host, port), VNCHandler) as server:
        server.serve_forever()


if __name__ == "__main__":
    sys.exit(main())
