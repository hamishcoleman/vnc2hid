#!/usr/bin/env python3
"""vnc2hid: A VNC server that extracts the HID events

Usage:
    vnc2hid <port>
"""

import sys
import socketserver
import struct

class Server(socketserver.TCPServer):
    """Just override the reuseaddr"""
    allow_reuse_address = True


class VNCProto():
    def __init__(self, sock):
        self.sock = sock

    def sendServerInit(self):
        width = 256
        height = 256
        bpp = 32
        depth = 24
        bigendian = False
        truecolor = True
        name = bytes('hid', 'utf8')

        buf = struct.pack(
            '!HHBB??HHHBBBxxxL',
            width, height, bpp, depth, bigendian,
            truecolor,
            255, 255, 255,  # rgb max
            16, 8, 0,       # rgb shift
            len(name)
        )
        buf += name
        self.sock.sendall(buf)


class VNCProto3(VNCProto):
    def doSecurityHandshake(self):
        # 1==no authentication
        self.sock.sendall(b"\x00\x00\x00\x01")


class VNCProto8(VNCProto):
    def doSecurityHandshake(self):
        # Send Security Handshake
        # list of 1 security type, it is 1=="None"
        self.sock.sendall(b"\x01\x01")

        # Recv Chosen security type
        got = self.sock.recv(1024)
        assert(b"\x01" == got)

        # Send SecurityResult
        self.sock.sendall(b"\x00\x00\x00\x00")


class VNCHandler(socketserver.BaseRequestHandler):

    def _doVersion(self):
        version=b"RFB 003.008\n"
        self.request.sendall(version)

        got = self.request.recv(1024).strip()
        print("Client Version:{}", got)

        if (got == b'RFB 003.008'):
            self.vnc = VNCProto8(self.request)
            return

        # The standard says "if you dont know the proto, it is probably 3.3"
        self.vnc = VNCProto3(self.request)

    def handle(self):
        """Incoming connections end up here"""
        print("New connection")

        self._doVersion()
        self.vnc.doSecurityHandshake()

        # Recv ClientInit
        self.request.recv(1)
        # we dont care what the sharing state is..

        self.vnc.sendServerInit()

        # We should now be dealing with messages
        while (True):
            msg = self.request.recv(2048)
            if not msg:
                return

            number = msg[0]

            print("msg{} len={}".format(number, len(msg)))

def main():
    if len(sys.argv) < 2:
        print(__doc__)
        return 0

    sys.argv.pop(0)
    host = ''
    port = sys.argv.pop(0)

    try:
        port = int(port)
    except ValueError:
        print("Invalid port:", port)
        return 1

    with Server((host, port), VNCHandler) as server:
        server.serve_forever()

if __name__ == "__main__":
    sys.exit(main())
