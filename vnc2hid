#!/usr/bin/env python3
"""vnc2hid: A VNC server that extracts the HID events

Usage:
    vnc2hid <port>
"""

import sys
import socketserver
import struct

class Server(socketserver.TCPServer):
    """Just override the reuseaddr"""
    allow_reuse_address = True


class VNCProto():
    def __init__(self, rfile, wfile):
        self.rfile = rfile
        self.wfile = wfile

    def handle(self):
        # We should now be dealing with messages
        while (True):
            result = self.read()
            if not result:
                return

    def read(self):
        """Process incoming bytes."""

        msgtypes = {
            0: 'SetPixelFormat',
            2: 'SetEncodings',
            3: 'FramebufferUpdateRequest',
            4: 'KeyEvent',
            5: 'PointerEvent',
            6: 'ClientCutText',
        }

        buf = self.rfile.read(1)
        if not buf:
            return None
        msgid = ord(buf)

        if msgid not in msgtypes:
            print("ABORT: Unknown message-type {}".format(msgid))
            # If we dont know the message, we will probably end up with an
            # unsynced protocol stream, so the exception will kill off our
            # connection and force a reconnect.
            raise ValueError

        msgname = msgtypes[msgid]
        print("{} {}".format(msgid, msgname))

        handler = getattr(self, 'recv_'+msgname, None)
        if callable(handler):
            return handler()

        return None

    def sendServerInit(self):
        width = 256
        height = 256
        bpp = 32
        depth = 24
        bigendian = False
        truecolor = True
        name = bytes('hid', 'utf8')

        buf = struct.pack(
            '!HHBB??HHHBBBxxxL',
            width, height, bpp, depth, bigendian,
            truecolor,
            255, 255, 255,  # rgb max
            16, 8, 0,       # rgb shift
            len(name)
        )
        buf += name
        self.wfile.write(buf)

    def recv_SetPixelFormat(self):
        self.rfile.read(19)
        return True

    def recv_SetEncodings(self):
        self.rfile.read(1) # padding
        count = int.from_bytes(self.rfile.read(2),'big')
        self.rfile.read(count*4) # encoding list
        return True

    def recv_FramebufferUpdateRequest(self):
        self.rfile.read(9)
        return True

    def recv_KeyEvent(self):
        self.rfile.read(7)
        return True

    def recv_PointerEvent(self):
        self.rfile.read(5)
        return True

    def recv_ClientCutText(self):
        self.rfile.read(3) # padding
        length = int.from_bytes(self.rfile.read(4),'big')
        self.rfile.read(length)
        return True


class VNCProto3(VNCProto):
    def doSecurityHandshake(self):
        # 1==no authentication
        self.wfile.write(b"\x00\x00\x00\x01")


class VNCProto8(VNCProto):
    def doSecurityHandshake(self):
        # Send Security Handshake
        # list of 1 security type, it is 1=="None"
        self.wfile.write(b"\x01\x01")

        # Recv Chosen security type
        got = self.rfile.read(1)
        assert(b"\x01" == got)

        # Send SecurityResult
        self.wfile.write(b"\x00\x00\x00\x00")


class VNCHandler(socketserver.StreamRequestHandler):

    def _doVersion(self):
        version=b"RFB 003.008\n"
        self.wfile.write(version)

        got = self.rfile.readline().strip()
        print("Client Version:{}", got)

        if (got == b'RFB 003.008'):
            self.vnc = VNCProto8(self.rfile, self.wfile)
            return

        # The standard says "if you dont know the proto, it is probably 3.3"
        self.vnc = VNCProto3(self.rfile, self.wfile)

    def handle(self):
        """Incoming connections end up here"""
        print("New connection")

        self._doVersion()
        self.vnc.doSecurityHandshake()

        # Recv ClientInit
        self.rfile.read(1)
        # we dont care what the sharing state is..

        self.vnc.sendServerInit()
        self.vnc.handle()

def main():
    if len(sys.argv) < 2:
        print(__doc__)
        return 0

    sys.argv.pop(0)
    host = ''
    port = sys.argv.pop(0)

    try:
        port = int(port)
    except ValueError:
        print("Invalid port:", port)
        return 1

    with Server((host, port), VNCHandler) as server:
        server.serve_forever()

if __name__ == "__main__":
    sys.exit(main())
